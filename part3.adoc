= Part III. Spring Boot 사용
이 섹션에서는 Spring Boot를 어떻게 사용하는지에 대해 자세히 살펴볼 것이다. 빌드 시스템, 자동 구성 및 application 실행 방법과 같은 항목을 다룬다. Spring Boot에 대해 특별히 특별한 것은 없지만(사용할 수 있는 다른 라이브러리일 뿐) 개발 프로세스를 좀 더 쉽게 만들 수 있는 몇 가지 권장 사항이 있다.

Spring Boot를 시작하는 경우, 이 섹션에 들어가기 전에 시작하기 가이드를 읽어야 한다.

== 13. 빌드 시스템
의존성 관리를 지원하고 "Maven Central" 저장소에 게시된 artifact를 사용할 수 있는 빌드 시스템을 선택하는 것이 좋다. Maven 또는 Gradle을 선택하는 것을 추천한다. Spring Boot가 다른 빌드 시스템(예: Ant)과 함께 사용할 수 있지만, 잘 지원되지는 않는다.

== 13.1 의존성 관리
Spring Boot의 각 릴리즈는 지원하는 의존성 목록을 제공한다. 실제로 Spring Boot가 이를 관리하므로 빌드 구성에서 의존성에 대한 버전을 제공할 필요가 없다. Spring Boot 자체를 업그레이드하면 의존성도 일관된 방식으로 업그레이드 된다.

[NOTE]
====
필요한 경우 버전을 직접 지정하고 Spring Boot의 권장 사항을 재정의 할 수 있다.
====

선별된 목록에는 Spring Boot와 함께 사용할 수 있는 모든 Spring 모듈과 서드파티 라이브러리의 목록이 포함된다. 이 목록은 Maven과 Gradle에서 모두 사용할 수 있는 표준 Bills of Material(spring-bootdependencies)으로 제공된다.

[WARNING]
====
Spring Boot의 각 릴리즈는 Spring Framework의 기본 버전과 연결된다. 해당 버전을 지정하지 않는것을 권장한다.
====

== 13.2 Maven
Maven 사용자는 spring-boot-starter-parent 프로젝트를 상속 받아 기본값을 얻을 수 있다. 상위 프로젝트는 다음과 같은 기능을 제공한다:

* Java 1.8을 기본 컴파일러로 사용한다.
* UTF-8 소스 인코딩
* 의존성 관리 섹션에서 봤듯이, spring-boot 의존성 pom을 상속하면 공톡적인 의존성의 버전을 관리한다. 이 의존성 관리를 사용하면 사용자 자신의 pom에서 사용될 때 해당 의존성에 대한 <version> 태그를 생략할 수 있다.
* repackage 실행 id로 repackage 골을 실행한다.
* 리소스 필터링
* 플러그인 설정(http://www.mojohaus.org/exec-maven-plugin/[exec plugin], https://github.com/ktoso/maven-git-commit-id-plugin[Git commit ID]와 https://maven.apache.org/plugins/maven-shade-plugin/[shade])
* 프로필 관련 파일(예: application-dev.properties 및 application dev.yml)을 비롯하여 application.properties 및 application.yml의 리소스 필터링

주의할 점은, application.properties 및 application.yml 파일은 Spring 스타일의 placeholder(${...})를 사용하므로 Maven 필터링은 @ .. @ placeholder를 사용하도록 변경된다.

=== Starter Parent 상속
spring-boot-starter-parent에서 상속하도록 프로젝트를 구성하려면 다음과 같이 부모를 설정하시오:

[source,xml]
----
<!-- Spring Boot에서 기본값 상속 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.0.BUILD-SNAPSHOT</version>
</parent>
----

[NOTE]
====
Spring Boot 버전은 이 의존성에만 추가하면 된다. 만약 추가 스타터를 사용하는 경우 버전을 생략할 수 있다.
====

이 설정을 사용하면 자신의 프로젝트에서 속성을 재정의하여 각각 의존성을 재정의할 수 있다. 예를 들어 다른 Spring Data 릴리즈 트레인으로 업그레이드 하려면 다음을 pom.xml에 추가하면 된다:

[source,xml]
----
<properties>
    <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
</properties>
----

[TIP]
====
지원되는 속성 목록은 https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-dependencies/pom.xml[spring-boot-dependencies pom]을 확인하시오.
====

=== 부모 POM 없이 Spring Boot 사용하기
모든 사람이 spring-boot-starter-parent POM으로부터 상속받는 것을 좋아하지 않는다. 기업 표준 parent를 사용해야 할 수도 있고, 모든 Maven 구성을 명시적으로 선언하는 것을 선호할 수도 있다.

spring-boot-starter-parent를 사용하지 않으려면 scope = import 의존성을 사용해 의존성 관리(플러그인 관리 제외)를 받을 수 있다.:

[source,xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.1.0.BUILD-SNAPSHOT</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

위 예제 설정에서는 위에서 설명한 대로 속성을 사용하여 개별 의존성을 재정의할 수 없다. 동일한 결과를 얻으려면 spring-boot-dependencies 설정 전에 프로젝트의 dependencyManagement에 설정을 추가해야한다. 예를 들어 다른 Spring Data 릴리즈 트레인으로 업그레이드하려면 다음 요소를 pom.xml에 추가해야 한다:

[source,xml]
----
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot가 제공하는 Spring Data 릴리즈 트레인 재정의 -->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-releasetrain</artifactId>
            <version>Fowler-SR2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.1.0.BUILD-SNAPSHOT</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

[NOTE]
====
위 예제에서는 BOM을 지정하지만 모든 의존성 타입은 동일한 방법으로 재정의할 수 있다.
====

=== Spring Boot Maven 플러그인 사용하기
Spring Boot는 프로젝트를 실행 가능한 jar로 패키징할 수 있는 Maven 플러그인을 포함한다. 다음 예제와 같이 플러그인을 사용하려면 <plugins> 섹션에 플러그인을 추가하시오:

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
----

[NOTE]
====
Spring Boot 스타터 부모 pom을 사용하는 경우, 플러그인만 추가하면 된다. 부모에 정의된 설정을 변경하려는 경우가 아니면 다른 설정은 필요없다.
====

== 13.3 Gradle
Gradle을 이용하여 Spring Boot를 사용하는 것을 배우려면 Spring Boot의 Gradle 플러그인 문서를 참조하시오.

* 참조문서(https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/gradle-plugin/reference/html[HTML], https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf[PDF])
* https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/gradle-plugin/api[API]

== 13.4 Ant
Apache Ant+Ivy를 사용하여 Spring Boot 프로젝트를 빌드하는 것이 가능하다. spring-boot-antlib "AntLib" 모듈을 사용하면 Ant로 실행 가능한 jar를 생성할 수 있다.

의존성을 선언하기 위해 ivy.xml 파일을 다음 예제와 같이 작성한다:

[source,xml]
----
<ivy-module version="2.0">
    <info organisation="org.springframework.boot" module="spring-boot-sample-ant" />
    <configurations>
        <conf name="compile" description="everything needed to compile this module" />
        <conf name="runtime" extends="compile" description="everything needed to run this module" />
    </configurations>
    <dependencies>
        <dependency org="org.springframework.boot" name="spring-boot-starter" rev="${spring-boot.version}" conf="compile" />
    </dependencies>
</ivy-module>
----

build.xml 파일은 다음 예제와 같다:

[source,xml]
----
<project xmlns:ivy="antlib:org.apache.ivy.ant" xmlns:spring-boot="antlib:org.springframework.boot.ant" name="myapp"
    default="build">
    <property name="spring-boot.version" value="2.1.0.BUILD-SNAPSHOT" />
    <target name="resolve" description="--> retrieve dependencies with ivy">
        <ivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" />
    </target>
    <target name="classpaths" depends="resolve">
        <path id="compile.classpath">
            <fileset dir="lib/compile" includes="*.jar" />
        </path>
    </target>
    <target name="init" depends="classpaths">
        <mkdir dir="build/classes" />
    </target>
    <target name="compile" depends="init" description="compile">
        <javac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" />
    </target>
    <target name="build" depends="compile">
        <spring-boot:exejar destfile="build/myapp.jar" classes="build/classes">
            <spring-boot:lib>
                <fileset dir="lib/runtime" />
            </spring-boot:lib>
        </spring-boot:exejar>
    </target>
</project>
----

[TIP]
====
spring-boot-antlib 모듈을 사용하고싶지 않다면, 섹션 90.9 "spring-boot-antlib 사용하지 않고 Ant에서 실행가능한 아카이브 만들기" "방법"을 참조하시오.
====

== 13.5 Starters
스타터(Starters)는 application에 포함할 수 있는 편리한 의존성 설명자들이다. 샘플 코드를 검색하거나 의존성의 많은 부분을 복사하지 않고 필요한 모든 Spring 및 관련 기술을 원스탑으로 얻을 수 있다. 예를 들어, 데이터베이스 엑세스를 위해 Spring과 JPA를 사용하려면 프로젝트에 spring-boot-starter-data-jpa 의존성을 추가하면 된다.

스타터에는 프로젝트를 빠르게 시작하고 실행하는 데 필요한 많은 의존성이 포함되어 있으며, 의존성들의 전이도 지원한다.

[subs=+quotes]
....
*What's in a name*

모든 *공식* 스사터들은 비슷한 이름 지정 패턴을 따른다. spring-boot-starter-*, *는 특정 유형의 application이다. 이 명명 구조는 스타터를 찾는 것을 도와준다. Maven과 연동하는 많은 IDE들은 이름으로 의존성을 검색할 수 있다. 예를 들어 Eclipse 또는 STS 플러그인이 설치된 경우 POM 편집기에서 ctrl-space를 누르고 "spring-boot-starter"를 입력하면 완성 목록이 나온다.

"나만의 스타터 만들기" 섹션에 설명된 것 같이, 서드파티 스타터들은 공식적인 Spring Boot 아트팩트에서 제공하는 것처럼 spring-boot로 시작하지 않을 수 있다. 오히려 서드파티 스타터들은 일반적으로 프로젝트 이름으로 시작한다. 예를 들어 thirdpartyproject라는 서드파티 프로젝트는 일반적으로 thirdpartyproject-spring-bootstarter라는 이름을 갖는다.
....

다음 application 스타더들은 org.springframework.boot 그룹의 Spring Boot가 제공하는 스타터들이다:

[caption=""]
.표 13.1. Spring Boot application 스타터들
|===
|Name |Description |Pom
|spring-boot-starter |코어 스타터로 자동설정 지원과 로깅 및 YAML을 포함 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter/pom.xml[Pom]
|spring-boot-starter-activemq |Apache ActiveMQ 사용하여 JMS 메시징을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-activemq/pom.xml[Pom]
|spring-boot-starter-amqp |Spring AMQP와 Rabbit MQ 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-amqp/pom.xml[Pom]
|spring-boot-starter-aop |Spring AOP와 AspectJ를 이용한 관점-지향 프로그래밍을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-aop/pom.xml[Pom]
|spring-boot-starter-artemis |Apache Artemis를 사용하여 JMS 메시징을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-artemis/pom.xml[Pom]
|spring-boot-starter-batch |Spring Batch 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-batch/pom.xml[Pom]
|spring-boot-starter-cache |Spring Framework의 캐싱 지원 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-cache/pom.xml[Pom]
|spring-boot-starter-cloud-connectors |Cloud Foundry와 Heroku 같은 클라우드 플랫폼을 쉽게 연결할 수 있는 Spring Cloud Connector를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-cloud-connectors/pom.xml[Pom]
|spring-boot-starter-data-cassandra |분산 데이터베이스 Cassandra와 Spring Data Cassandra를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra/pom.xml[Pom]
|spring-boot-starter-data-cassandra-reactive |분산 데이터베이스 Cassandra와 Spring Data Cassandra Reactive 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra-reactive/pom.xml[Pom]
|spring-boot-starter-data-couchbase |문서지향 데이터베이스 Couchbase와 Spring Data Couchbase 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase/pom.xml[Pom]
|spring-boot-starter-data-couchbase-reactive |문서지향 데이터베이스 Couchbase와 Spring Data Couchbase Reactive 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase-reactive/pom.xml[Pom]
|spring-boot-starter-data-elasticsearch |Elasticsearch 검색과 분석엔진 및 Spring Data Elasticsearch 사용을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-elasticsearch/pom.xml[Pom]
|spring-boot-starter-data-jpa |Hibernate와 Spring Data JPA를 사용하기 위한 스타터|https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jpa/pom.xml[Pom]
|spring-boot-starter-data-ldap |Spring Data LDAP을 사용하기 위한 스사터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-ldap/pom.xml[Pom]
|spring-boot-starter-data-mongodb |문서지향 데이터베이스 MongoDB와 Spring Data MongoDB를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb/pom.xml[Pom]
|spring-boot-starter-data-mongodb-reactive |문서지향 데이터베이스 MongoDB와 Spring Data MongoDB Reactive를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb-reactive/pom.xml[Pom]
|spring-boot-starter-data-neo4j |그래프 데이터베이스 Neo4j와 Spring Data Neo4j를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-neo4j/pom.xml[Pom]
|spring-boot-starter-data-redis |Spring Data Redis와 Lettuce client를 이용해 key-value 데이터 저장소인 Redis를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis/pom.xml[Pom]
|spring-boot-starter-data-redis-reactive |Spring Data Redis reactive와 Lettuce client를 이용해 key-value 데이터 저장소인 Redis를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis-reactive/pom.xml[Pom]
|spring-boot-starter-data-rest |Spring Data REST를 이용해 Spring Data repository들을 나타내기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-rest/pom.xml[Pom]
|spring-boot-starter-data-solr |Spring Data Solr를 이용해 Apache Solr search 플랫폼을 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-data-solr/pom.xml[Pom]
|spring-boot-starter-freemarker |FreeMarker 뷰를 이용하여 MVC web application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-freemarker/pom.xml[Pom]
|spring-boot-starter-groovy-templates |Groovy 템플릿 뷰를 이용하여 MVC web application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-groovy-templates/pom.xml[Pom]
|spring-boot-starter-hateoas |Spring MVC와 Spring HATEOAS를 이용해 하이퍼미디어 기반 RESTful web application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-hateoas/pom.xml[Pom]
|spring-boot-starter-integration |Spring Integration을 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-integration/pom.xml[Pom]
|spring-boot-starter-jdbc |HikariCP 커넥션 풀을 이용하여 JDBC를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-jdbc/pom.xml[Pom]
|spring-boot-starter-jersey |JAX-RS와 Jersey를 이용하여 RESTful web application을 빌드하기 위한 스타터. spring-boot-starter-web를 대신함 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-jersey/pom.xml[Pom]
|spring-boot-starter-jooq |SQL 데이터베이스에 접근하기 위한 jOOQ를 사용하기 위한 스타터. spring-boot-starter-data-jpa
또는 spring-boot-starterjdbc를 대신함 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-jooq/pom.xml[Pom]
|spring-boot-starter-json |json을 읽고 쓰기위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-json/pom.xml[Pom]
|spring-boot-starter-jta-atomikos |Atomikos를 사용하는 JTA 트랜잭션을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-atomikos/pom.xml[Pom]
|spring-boot-starter-jta-bitronix |Bitronix를 사용하는 JTA 트랜잭션을 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-bitronix/pom.xml[Pom]
|spring-boot-starter-mail |Java 메일과 Spring Framework의 이메일 전송 지원을 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-mail/pom.xml[Pom]
|spring-boot-starter-mustache |Mustache 뷰를 사용하여 web application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-mustache/pom.xml[Pom]
|spring-boot-starter-oauth2-oidc-client |Spring Security의 OAuth2/OpenID Connect 클라이언트 기능을 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-oidc-client/pom.xml[Pom]
|spring-boot-starter-quartz |Quartz 스케쥴러를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-quartz/pom.xml[Pom]
|spring-boot-starter-security |Spring Security를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-security/pom.xml[Pom]
|spring-boot-starter-test |JUnit, Hamcrest와 Mockito 라이브러리를 사용하여 Spring Boot application을 테스팅하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/pom.xml[Pom]
|spring-boot-starter-thymeleaf |Thymeleaf 뷰를 사용하여 MVC web application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-thymeleaf/pom.xml[Pom]
|spring-boot-starter-validation |Hibernate Validator로 Java Bean 검증을 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-validation/pom.xml[Pom]
|spring-boot-starter-web |Spring MVC를 이용한 RESTful을 포함한 web application을 빌드하기 위한 스타터. Tomcat을 기본 내장형 컨테이너로 사용 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-web/pom.xml[Pom]
|spring-boot-starter-web-services |Spring Web 서비스를 이용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-web-services/pom.xml[Pom]
|spring-boot-starter-webflux |Spring Framework의 Reactive 웹 지원을 이용해 WebFlux application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-webflux/pom.xml[Pom]
|spring-boot-starter-websocket |Spring Framework의 WebSocket 지원을 이용해 WebSocket application을 빌드하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-websocket/pom.xml[Pom]
|===

application 스타터 외에도 다음 스타터를 사용하여 프로덕션 준비 기능을 추가할 수 있다:

[caption=""]
.표 13.2. Spring Boot 프로덕션 스타터들
|===
|Name |Description |Pom
|spring-boot-starter-actuator |application을 모니터링하고 관리하는데 도움이 되는 프로덕션 준비 기능을 제공하는 Spring Boot의 Actuator를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-actuator/pom.xml[Pom]
|===

마지막으로, Spring Boot는 특정 기술적 측면을 제외하거나 변경하려는 경우 사용할 수 있는 다음 스타터들을 포함한다.

[caption=""]
.표 13.3. Spring Boot 기술적 스타터들
|===
|Name |Description |Pom
|spring-boot-starter-jetty |내장형 서블릿 컨테이너로 Jetty를 사용하기 위한 스타터. spring-boot-starter-tomcat을 대신함 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-jetty/pom.xml[Pom]
|spring-boot-starter-log4j2 |로깅을 위한 Log4j2를 사용하기 위한 스타터. spring-boot-starter-logging을 대신함 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-log4j2/pom.xml[Pom]
|spring-boot-starter-logging |Logback을 사용하여 로깅을 위한 스타터. 기본 로깅 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-logging/pom.xml[Pom]
|spring-boot-starter-reactor-netty |내장형 reactive HTTP 서버로 Reactor Netty를 사용하기 위한 스타터 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-reactor-netty/pom.xml[Pom]
|spring-boot-starter-tomcat |내장형 서블릿 컨테이너로 톰캣을 사용하기 위한 스타터. 기본 서블릿 컨테이너 스타터로 spring-boot-starter-web이 사용됨 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-tomcat/pom.xml[Pom]
|spring-boot-starter-undertow |내장형 서블릿 컨테이너로 Unsertow를 사용하기 위한 스타터. spring-boot-starter-tomcat을 대신함 |https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/spring-boot-starter-undertow/pom.xml[Pom]
|===

[TIP]
====
추가로 커뮤니티가 기여한 스타터 목록은 GitHub의 spring-boot-starters 모듈에 있는 https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/README.adoc[README] 파일을 참조하시오.
====

== 14. 코드 구성
Spring Boot를 작동하려면 특정 코드 레이아웃이 필요하지 않다. 하지만 도움이 되는 몇 가지 모범 사례가 있다.

== 14.1 "default" 패키지 사용하기
클래스에 패키지 선언이 포함되어 있지 않으면 "default 패키지"에 있는 것으로 간주된다. 일반적으로 "default 패키지" 사용은 권장되지 않으며 피해야 한다. Spring Boot application 는 모든 jar의 모든 클래스를 읽기 때문에 @ComponetScan, @EntityScan, 또는 @SpringBootApplication 어노테이션을 사용하면 문제가 발생할 수 있다.

[TIP]
====
Java 권장 패키지 네이밍 규칙을 따르고 도메인 이름을 역으로(예: com.example.project) 사용하는 것이 좋다.
====

== 14.2 Main Application Class 위치
일반적으로 메인 application 클래스를 다른 클래스보다 상위에 있는 루트 패키지에 배치하는 것이 좋다. @SpringBootApplication 어노테이션은 주로 메인 클래스에 배치되며, 특정 항목에 대한 기본 "검색 패키지"를 암시적으로 정의한다. 예를 들어, JPA application을 작성하는 경우 @SpringBootApplication 어노테이션으로 된 클래스 패키지는 @Entity 아이템을 검색하는데 사용된다. 루트 패키지를 사용하면 컴포넌트 검사를 프로젝트에만 적용할 수 있다.

[TIP]
====
@SpringBootApplication을 사용하지 않으려면 @EnableAutoConfiguration과 @ComponentScan 어노테이션이 가져온 동작을 정의하여 대신 사용할 수 있다.
====

다음 목록은 일반적인 레이아웃을 보여준다:

[subs=+quotes]
....
com
 +- example
    +- myapplication
        +- Application.java
        |
        +- customer
        |   +- Customer.java
        |   +- CustomerController.java
        |   +- CustomerService.java
        |   +- CustomerRepository.java
        |
    +- order
            +- Order.java
            +- OrderController.java
            +- OrderService.java
            +- OrderRepository.java
....

Application.java 파일은 기본 @SpringBootApplication과 함께 main 메소드를 다음과 같이 선언한다:

[source,java]
----
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }

}
----

== 15. 설정 클래스
Spring Boot는 Java 기반 설정을 선호한다. XML 소스로 SpringApplication을 사용하는 것이 가능하지만, 일반적으로 기본 소스로 단일 @Configuration 클래스를 갖는 것을 권장한다. 일반적으로 메인 메소드를 정의하는 클래스는 기본 @Configuration으로 좋은 후보이다.

[TIP]
====
XML 설정을 사용하는 많은 Spring 설정 예제가 인터넷에 게시되어 있다. 가능하면 항상 동등한 Java 기반 설정을 사용하시오. Enable* 어노테이션을 검색하는 것이 좋은 시작점이 될 수 있다.
====

== 15.1 추가 설정 클래스들 가져오기
모든 @Configuration을 단일 클래스에 넣을 필요는 없다. @Import 어노테이션을 사용하여 추가 설정 클래스들을 가져올 수 있다. 또는 @ComponentScan을 사용하여 @Configuration 클래스를 포함한 모든 Spring 설정 요소를 자동으로 선택할 수 있다.

== 15.2 XML 설정 가져오기
XML 기반 설정을 사용해야 하는 경우 @Configuration 클래스로 시작하는 것이 좋다. 그런 다음 @ImportResource 어노테이션을 사용하여 XML 설정 파일을 로드할 수 있다.

== 16. 자동 설정
Spring Boot 자동 설정은 당신이 추가한 jar 의존성에 따라 Spring application을 자동 설정을 시도한다. 예를 들어 HSQLDB가 classpath에 있고 데이터베이스 연결 빈들을 수동으로 설정하지 않았다면, Spring Boot는 인 메모리 데이터베이스를 자동으로 설정한다.

@EnableAutoConfiguration 또는 @SpringBootApplication 어노테이션을 @Configuration 클래스들 중 하나에 추가하여 자동 설정을 수행할 수 있다.

[TIP]
====
@SpringBootApplication 또는 @EnableAutoConfiguration 어노테이션 하나만 추가해야 한다. 일반적으로 기본 @Configuration 클래스에만 둘중 하나를 추가하는 것이 좋다.
====

== 16.1 점차적으로 자동 설정 대체하기
자동 설정은 비 침습적이다(non-invasive). 언제든지 자동 설정의 특정 부분을 대체하는 자체 설정을 정의할 수 있다. 예를 들어 자신만의 DataSource 빈을 추가하면 기본 내장 데이터베이스 지원은 사라진다.

현재 어떤 자동 설정이 적용되고 있는지, 그 이유를 확인해야 하는 경우 --debug 옵션으로 application을 시작하시오. 이렇게 하면 핵심 로그 중 일부에 대한 디버그 로그가 활성화 되고 콘솔에 조건들의 보고서를 기록한다.

== 16.2 특정 자동 설정 클래스들 비활성화 하기
원하지 않는 특정 자동 설정 클래스가 적용되는 경우 다음 예제와 같이 @EnableAutoConfiguration의 제외 속성을 사용하여 해당 클래스를 사용하지 않도록 설정할 수 있다:

[source,java]
----
import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;
import org.springframework.context.annotation.*;

@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}
----

클래스가 classpath에 없으면 어노테이션의 excludeName 속성을 사용하고 대신 전체 이름을 지정할 수 있다. 마지막으로, spring.autoconfigure.exclude 속성을 사용하여 제외할 자동 설정 클래스 목록을 제어할 수 있다.

[TIP]
====
어노테이션 레벨과 프로퍼티를 사용하여 제외를 정의할 수 있다.
====

== 17. Spring 빈들과 의존성 주입
빈들을 정의하고 의존성 주입을 받기위해 어떠한 표준 Spring Framework 기술이든 사용할 수 있다. 간단히, @ComponentScan(빈들을 찾기 위해 사용)과 @Autowired(생성자 주입을 위해 사용)을 이용하면 잘 작동한다.

코드 구조가 위에 설명한 대로 구조하였다면(application 클래스를 root 패키지에 위치함) 인자 값 없이 @ComponetScan을 추가할 수 있다. 모든 application 컴포넌트들(@Componet, @Service, @Repository, @Controller 등)은 자동으로 Spring Beans로 등록된다.

다음 예제는 RiskAssessor 빈을 얻기 위해 생성자 주입을 사용하는 @Service 빈을 보여준다.

[source,java]
----
package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

private final RiskAssessor riskAssessor;

@Autowired
public DatabaseAccountService(RiskAssessor riskAssessor) {
  this.riskAssessor = riskAssessor;
}

  // ...

}
----

빈에 하나의 생성자만 존재하면 다음 예제와 같이 @Autowired를 생략할 수 있다.

[source,java]
----
@Service
public class DatabaseAccountService implements AccountService {

private final RiskAssessor riskAssessor;

public DatabaseAccountService(RiskAssessor riskAssessor) {
  this.riskAssessor = riskAssessor;
}

  // ...
  
}
----

[TIP]
====
필드가 final인 riskAssessor에 생성자 주입을 사용하는 것은 나중에 변경 할 수 없다는 것을 나타낸다.
====

== 18. @SpringBootApplication 어노테이션 사용하기
많은 Spring Boot 개발자는 자동 설정, 컴포넌트 검사를 사용하고 "application 클래스"에서 추가 설정을 정의할 수 있는 app을 좋아한다. 단일 @SpringBootApplication 주석을 사용하여 다음과 같이 세 가지 기능을 사용할 수 있다:

* @EnableAutoConfiguration: Spring Boot의 자동 설정 메카니즘 활성화
* @ComponentScan: application이 있는 패키지에서 @Component 검색 활성화(모범 사례 참조)
* @Configuration: 추가 빈을 컨텍스트에 등록하거나 추가 설정 클래스를 가져올 수 있다.

@SpringBootApplication 어노테이션은 다음 예제와 같이 @Configuration, @EnableAutoConfiguration 및 @ComponentScan을 기본 속성과 함께 사용하는 것과 같다:

[source,java]
----
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // @Configuration @EnableAutoConfiguration @ComponentScan를 선언한 것과 같다.
public class Application {

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}
----

[NOTE]
====
@SpringBootApplication은 @EnableAutoConfiguration과 @ComponentScan의 속성을 사용자 정의할 수 있는 별칭을 제공한다.
====

[NOTE]
====
이 기능 중 어떤 것도 필수 사항이 아니며, 이 단일 어노테이션을 사용할 수 있는 기능으로 대체하도록 선택할 수 있다. 예를들어 application에서 컴포넌트 검색을 사용하지 않을 수 있다:

[source,java]
----
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@EnableAutoConfiguration
@Import({ MyConfig.class, MyAnotherConfig.class })
public class Application {

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }

}
----

이 예제에서 Application은 @Component-annotated 클래스들이 자동으로 검색되지 않고 사용자 정의 빈이 명시적으로 가져와 지는 것을 제외하면 다른 Spring Boot application과 동일하다.(@Import 참조)
====

== 19. Application 실행하기
application을 jar로 패키징하고 내장된 HTTP 서버를 사용하는 것의 가장 큰 장점 중 하나는 application을 다른 application과 같은 방법으로 실행시킬 수 있다는 것이다. Spring Boot application을 디버깅하는 것도 쉽다. 특별한 IDE 플러그인 또는 확장 기능이 필요 없다.

[NOTE]
====
이 섹션에서는 jar 기반 패키징을 다룬다. application을 war 파일로 패키징하려면 당신의 서버와 IDE 문서를 참조하시오.
====

== 19.1 IDE에서 실행하기
간단한 Java application처럼 Spring Boot application을 IDE에서 실행할 수 있다. 그러나 먼저 프로젝트를 가져와야 한다. 가져오는 단계는 IDE 및 빌드 시스템에 따라 다르다. 대부분의 IDE는 Maven 프로젝트를 직접 가져올 수 있다. 예를들어, 이클립스 사용자는 Import… → Existing Maven Projects from the File menu를 사용할 수 있다.

IDE로 프로젝트를 직접 가져올 수 없는 경우 빌드 플러그인을 사용하여 IDE 메타데이터를 생성할 수 있다. Maven에는 https://maven.apache.org/plugins/maven-eclipse-plugin/[Eclipse] 및 https://maven.apache.org/plugins/maven-idea-plugin/[IDEA]용 플러그인이 포함되어 있다. Gradle은 https://docs.gradle.org/4.2.1/userguide/userguide.html[다양한 IDE]용 플러그인을 제공한다.

[TIP]
====
web application을 실수로 두 번 실행하면  "Port already in use" 오류가 표시된다. STS 사용자는 실행 단추 대신 재실행 단추를 사용하여 기존 인스턴스가 닫혔는지 확인할 수 있다.
====

== 19.2 패키징된 Application 실행하기
Spring Boot Maven 또는 Gradle 플러그인을 사용하여 실행 가능한 jar를 만드는 경우, 다음 예제와 같이 java -jar를 사용하여 application을 사용할 수 있다:

[source,bash]
----
$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar
----

또한 원격 디버깅 지원이 활성화 된 패키징된 application을 실행할 수 있다. 이렇게하면 다음 예제와 같이 패키징된 application에 디버거를 연결할 수 있다.

[source,bash]
----
$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
       -jar target/myapplication-0.0.1-SNAPSHOT.jar
----

== 19.3 Maven 플러그인 사용하기
Spring Boot Maven 플러그인에는 application을 신속하게 컴파일하고 실행하는 데 사용할 수 있는 실행 목표(goal)가 포함되어 있다. IDE에서와 같이 application은 분해된 형태로 실행된다. 다음 예에서 Spring Boot application을 실행하는 일반적인 Maven 명령을 보여준다:

[source,bash]
----
$ mvn spring-boot:run
----

다음 예제와 같이 MAVEN_OPTS 운영체제 환경 변수를 사용할 수 있다.

[source,bash]
----
$ export MAVEN_OPTS=-Xmx1024m
----

== 19.4 Gradle 플러그인 사용하기
Spring Boot Gralde 플러그인에는 application을 분해된 형태로 실행하는 데 사용할 수 있는 bootRun 태스크(task)가 포함되어 있다. bootRun 태스크는 org.springframework.boot 및 java 플러그인을 적용할 때마다 추가되며 다음 예제에 나와있다:

[source,bash]
----
$ gradle bootRun
----

다음 예제와 같이 JAVA_OPT 운영체제 환경 변수를 사용할 수 있다.

[source,bash]
----
$ export JAVA_OPTS=-Xmx1024m
----

== 19.5 Hot Swapping
Spring Boot application은 일반 Java application이므로 JVM 핫 스와핑을 바로 사용할 수 있다. JVM 핫 스와핑은 교체할 수 있는 바이트 코드는 제한적이다. 보다 완벽한 솔루션을 위해 https://zeroturnaround.com/software/jrebel/[JRebel]을 사용할 수 있다.

spring-boot-devtools 모듈에는 빠른 application 재시작을 지원한다. 자세한 내용은 이 장 뒷부분의 20장 개발자 도구 섹션과 핫 스와핑 "방법"을 참조하시오.

== 20. 개발자 도구들
Spring Boot에는 application 개발 환경을 좀 더 편하게 만들 수 있는 추가 도구들이 포함되어 있다. spring-boot-devtools 모듈은 개발할 때 사용할 수 있는 추가적인 기능들이 포함되어 있다. devtools 지원을 포함하려면 Maven 및 Gradle에 다음 목룍에 표시된 대로 의존성을 추가한다:

*Maven.*
[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
----

*Gradle.*
[source,gradle]
----
dependencies {
  compile("org.springframework.boot:spring-boot-devtools")
}
----

[NOTE]
====
전체 패키징된 application을 실행하면 개발자 도구가 자동으로 비활성화 된다. java -jar에서 application을 시작하거나 특수 클래스로더에서 application을 시작하면 "프로덕션 application"으로 간주된다. 의존성을 Maven에서 optional로 표시하거나 Gralde에서 compileOnly를 사용하는 것은 devtools가 프로젝트를 사용하는 다른 모듈에 일시적으로 적용되는 것을 방지하는 가장 좋은 방법이다.
====

[TIP]
====
리패키징된 아카이브에는 기본적으로 devtools가 포함되어 있지 않다. 특정 원격 devtools 기능을 사용하려면 excludeDevtools 빌드 속성을 사용하지 않도록 설정해야 한다. 이 속성은 Maven 플러그인과 Gradle 플러그인 모두 지원한다.
====

== 20.1 속성(Property) 기본값들
Spring Boot에서 지원하는 여러 라이브러리는 캐시를 사용하여 성능을 향상 시킨다. 예를 들어 템플릿 엔진은 컴파일 된 템플릿을 캐싱하여 템플릿 파일을 반복적으로 구문 분석하지 않도록 한다. 또한 Spring MVC는 정적 리소스를 제공할 때 응답에 HTTP 캐시 헤더를 추가할 수 있다.

캐시는 운영에서 매우 유용하지만 application에서 방금 변경한 내용을 볼 수 없는 개발 중 역효과를 낼 수 있다. 이러한 이유로 spring-bootdevtools는 기본적으로 캐싱 옵션을 사용하지 않도록 설정한다.

캐시 옵션은 application.properties 파일에 설정한다. 예를 들어, Thymeleaf는 spring.thymeleaf.cache 속성을 제공한다. spring-boot-devtools 모듈은 이러한 속성을 수동으로 설정하지 않고 자동으로 적절한 개발시점 설정을 자동으로 적용한다.

Spring MVC 및 Spring WebFlux application을 개발하는 동안 웹 요청에 대한 자세한 정보가 필요하므로 개발 도구가 Spring Framework 웹 인프라에 대한 DEBUG 로깅을 지원한다.

들어오는 요청, 처리자, 응답 결과 등을 제공한다. 모든 요청 세부 정보(잠재적으로 중요한 정보를 포함)를 기록하려면 spring.insights.web.log-request-details 설정 속성을 사용할 수 있다.

[TIP]
====
devtools에서 적용하는 속성의 전체 목록은 https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java[DevToolsPropertyDefaultsPostProcessor]를 참조하시오.
====

== 20.2 자동 재시작
spring-boot-devtools를 사용하는 application은 classpath의 파일이 변경될 때마다 자동으로 재시작 된다. 이 기능은 IDE에서 작업할 때 코드 변경에 매우 빠른 피드백 루프를 제공하므로 유용한 기능이다. 기본적으로 폴더를 가리키는 classpath의 모든 entry는 변경 사항을 모니터링한다. 정적 에셋(asset) 및 뷰 템플릿과 같은 특정 리소스는 application을 다시 시작할 필요가 없다.

[subs=+quotes]
....
*재시작 트리거(Triggering a restart)*

DevTools가 classpath 리소스를 모니터링하므로 재시작을 트리거하는 유일한 방법은 classpath를 업데이트하는 것이다. classpath를 업데이트하는 방법은 사용 중인 IDE에 따라 다르다. Eclipse에서 수정된 파일을 저장하면 classpath가 업데이트되고 재시작이 트리거된다. IntelliJ IDEA에서 프로젝트를 빌드하는 것(Build -> Build Project)도 동일한 효과를 가진다.
....

[NOTE]
====
forking이 활성화되어 있는 한 DevTools가 제대로 작동하려면 분리된 application 클래스로더가 필요하므로 지원되는 빌드 플러그인(Maven 및 Gradle)을 사용하여 application을 시작할 수 도 있다. 기본적으로 Gradle과 Maven은 classpath에서 DevTools를 탐지할 때 이 작업을 수행한다.
====

[TIP]
====
LiveReload와 함께 사용할 경우 자동 재시작은 잘 작동한다. 자세한 내용은 LiveReload 섹션을 참조하시오. JRebel을 사용하는 경우 동적 클래스 로딩을 위해 자동 재시작은 비활성화 된다. 다른 devtools 기능(LiveReload 및 속성 오버라이드 등)은 계속 사용할 수 있다.
====

[NOTE]
====
DevTools는 재시작하는 동안 application 컨텍스트의 shutdown 후크를 사용하여 닫는다. shutdown 후크(SpringApplication.setRegisterShutdownHook(false))를 비활성화한 경우 정상적으로 작동하지 않는다.
====

[NOTE]
====
classpath의 entry가 변경되어 다시 재시작을 트리거해야 하는지 결정할 때 DevTools는 spring-boot, spring-boot-devtools, spring-boot-autoconfigure, spring-boot-actuator와 srping-boot-starter 프로젝트를 자동으로 무시한다.
====

[NOTE]
====
DevTools는 ApplicationContext가 사용하는 ResourceLoader를 사용자 정의해야 한다. application이 이미 제공하는 경우에는 래핑(wrapped) 된다. ApplicationContext에 대한 getResource 메소드를 직접 오버라이드 하는 것은 지원되지 않는다.
====

[subs=+quotes]
....
* Restart vs Reload *

Spring Boot가 제공하는 재시작 기술은 두 개의 클래스로더를 사용하여 작동한다. 변경되지 않는 클래스(예: 서드파티 jar의 클래스)는 기본 클래스로더에 로드된다. 개발 중에 변경하는 클래스들은 restart 클래스로더에 로드된다. application이 재시작 되면 restart 클래스로더는 제거되고 새 클래스로더가 생성된다. 이 방식은 기본 클래스로더가 이미 사용 가능하고 이동만하면 되기 때문에 일반적으로 application 재시작이 "cold starts"보다 훨씬 더 빠르다.

만약 application 재시작이 빠르지 않거나 클래스로딩 문제가 발생하는 경우 ZeroTurnaround의 JRebel과 같은 reload 기술을 고려해보는 것이 좋다. 이 작업은 클래스가 로드될 때 다시 작성하여 reload가 쉽도록 한다.
....

=== 조건 평가로 변경사항 로깅하기
기본적으로 application을 재시작할 때마다 조건평가델타(condition evaluation delta) 보고서가 기록된다. 보고서는 빈들을(bean) 추가 또는 삭제 및 설정 프로퍼티등을 변경을 수행할 때 application의 자동 구성에 대한 변경 사항을 표시한다.

리프트 로깅을 중지하려면 다음 프로퍼티를 설정하시오:

[source]
----
spring.devtools.restart.log-condition-evaluation-delta=false
----

=== 리소스 제외하기
일부 리소스는 변경 시 재시작을 할 필요가 없다. 예를 들어 Thymeleaf 템플릿은 그 자리에서 편집할 수 있다. 기본적으로 /META_INF/maven, /META-INF/resources, /resources, /static, /public 또는 /template의 리소스를 변경하면 재시작이 트리거되지 않고 리로드가 트리거 된다. 이러한 제외 항목을 사용자 정의하려면 spring.devtools.restart.exclude 프로퍼티를 사용할 수 있다. 예를 들어 /static 및 /public만 제외하려면 다음 프로퍼티를 설정한다:

[source]
----
spring.devtools.restart.exclude=static/**,public/**
----

[TIP]
====
기본값을 유지하면서 추가적인 예외를 추가하려면 spring.devtools.restart.additional-exclude 프로퍼티를 대신 사용하시오.
====

=== 추가 경로 보기
클래스 경로에 없는 파일을 변경할 때 application을 재시작되거나 리로드되길 원할 수 있을 것이다. 그렇게 하기 위해 spring.devtools.restart.additionalpaths 프로퍼티를 사용하여 변경 사항을 감시하기 위한 추가 경로를 설정하시오. 앞에서 설명한 spring.devtools.restart.exclude 프로퍼티를 사용하여 완전 재시작 또는 라이브 리로드할 추가 경로를 설정할 수 있다.

=== 재시작 비활성화
재시작 기능을 사용하지 않으려면 spring.devtools.restart.enable 프로퍼티를 사용하여 재시작 기능을 중지할 수 있다. 대부분의 경우 application.properties에서 프로퍼티를 설정할 수 있다. (이렇게해도 재시작 클래스로더는 초기화되지만 파일 변경은 감시하지 않는다.)

재시작 지원을 완전히 비활성화 해야하는 경우 (예를 들어 특정 라이브러리를 사용할 때 작동하지 않는 경우) SpringApplication.run(...)을 호출하기 전에 spring.devtools.restart.enabled 시스템 프로퍼티를 false로 설정해야 한다. 다음 예제와 같다:

[source,java]
----
public static void main(String[] args) {
  System.setProperty("spring.devtools.restart.enabled", "false");
  SpringApplication.run(MyApp.class, args);
}
----

=== 트리거파일 사용하기
변경된 파일을 계속 컴파일하는 IDE로 작업하는 경우 특정 시점에만 재시작이 되는 것을 선호할 수 있다. 이렇게 하려면 재시작이 필요할 때만 수정되야 하는 특별한 파일인 "trigger file"을 사용할 수 있다. 파일을 변경하면 검사가 트리거되고 Devtools가 작업을 수행해야 한다는 것을 감지한 경우에만 재시작된다. 트리거 파일은 수동 또는 IDE 플러그인을 사용하여 업데이트 할 수 있다.

트리거 파일을 사용하려면 spring.devtools.restart.trigger-file 프로퍼티를 트리거 파일의 경로로 설정하시오.

[TIP]
====
모든 프로젝트가 동일한 방식으로 작동하도록 spring.devtools.restart.trigger-file을 전역으로 설정할 수 있다.
====

=== 재시작 클래스로더 커스터마이징
이전 Restart vs Reload 섹션에서 설명한 것처럼 재시작 기능은 두 개의 클래스로더를 사용하여 구현된다. 대부분 application에서 이 방법이 효과적이지만 가끔 클래스로딩 문제가 발생할 수 있다.

기본적으로 IDE에 열려있는 프로젝트는 "restart" 클래스로더가 로드되고 .jar 파일에는 "base" 클래스로더가 로드된다. 여러 모듈에서 작업하고 모든 모듈을 IDE로 가져오지 않은 경우 이것을 커스터마이징 할 필요가 있다. 이렇게 하기 위해 META-INF/spring-devtools.properties 파일을 만든다.

spring-devtools.properties 파일은 restart.exclude와 restart.include로 시작되는 프로퍼티들을 가질 수 있다. include 요소는 "restart" 클래스로더로 가져오고 exclude 요소는 "base" 클래스로더로 내려와야 하는 요소이다. 프로퍼티의 값은 클래스 경로에 적용되는 정규식 패턴이다. 다음 예제에서 볼 수 있다:

[source]
----
restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jar
restart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar
----

[NOTE]
====
모든 프로퍼티의 키는 고유해야 한다. 프로퍼티가 restart.include. 또는 restart.exclude.로 시작하기 때문에 주의해야 한다.
====

[TIP]
====
classpath의 모든 META-INF/spring-devtools.properties가 로드된다. 프로젝트 내부나 프로젝트가 사용하는 라이브러리 내부에 파일을 패키징할 수 있다.
====

=== 알려진 제한사항들
재시작 기능은 표준 ObjectInputStream을 사용하여 역직렬화(deserialize)된 객체에서 제대로 작동하지 않는다. 데이터를 역직렬화해야 하는 경우 Spring의 ConfigurableObjectInputStream을 Thread.currentThread().getContextClassLoader()와 함께 사용해야 한다.

불행히도 일부 서드파티 라이브러리는 컨텍스트 클래스로더를 고려하지 않고 역직렬화 한다. 이러한 문제가 발견되면 라이브러리 제작자에게 수정 사항을 요청해야 한다.

== 20.3 LiveReload
spring-boot-devtools 모듈에는 리소스가 변경될 때 웹브라우져 새로고침을 트리거하는 내장 LiveReload 서버가 포함되어 있다. http://livereload.com/extensions/[livereload.com]에서 Chrome, Firefox 및 Safari 용 LiveReload 브라우저 확장 프로그램을 제공한다.

application을 실행할 때 LiveReload 서버를 시작하지 않으려면 spring.devtools.livereload.enabled 프로퍼티를 false로 설정하면 된다.

[NOTE]
====
한 번에 하나의 LiveReload 서버만 실행할 수 있다. application을 시작하기 전에 실행 중인 다른 LiveReload 서버가 없는지 확인하시오. IDE에서 여러 application을 시작하는 경우 첫 번째 application만 LiveReload를 지원한다.
====

== 20.4 전역 설정들
$HOME 폴더에 .spring-bootdevtools.properties 파일을 추가하여 전역 devtools 설정을 할 수 있다.(파일 이름은 "."로 시작한다.) 이 파일에 추가된 프로퍼티들은 devtools를 사용하는 모든 Spring Boot application에 적용된다. 예를 들어 다음처럼 설정을 하면 tirgger file을 사용하여 항상 재시작을 설정할 수 있다.

*~/.spring-boot-devtools.properties.*

[source]
----
spring.devtools.reload.trigger-file=.reloadtrigger
----

== 20.5 원격 Applications
Spring Boot 개발 도구는 로컬 개발에만 국한되지 않는다. 원격으로 application을 실행할 때 몇 가지 기능을 사용할 수 있다. 원격 지원은 선택 사항이다. 이를 사용하려면 다음 목록에 표시된 것처럼 리패키징된 아카이브에 devtools가 포함되어 있는지 확인해야 한다.

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludeDevtools>false</excludeDevtools>
            </configuration>
        </plugin>
    </plugins>
</build>
----

다음 예제와 같이 spring.devtools.remote.secret 프로퍼티를 설정해야 한다:

[source]
----
spring.devtools.remote.secret=mysecret
----

[WARNING]
====
원격 application에서 spring-boot-devtools를 사용하도록 설정하면 보안상 위험할 수 있다. 프로덕션 배포에서는 절대 사용하지 말아야 한다.
====

원격 devtools 지원은 연결을 허용하는 서버 측 끝점(endpoint)과 IDE에서 실행하는 클라이언트 application의 두 부분으로 제공된다. spring.devtools.remote.secret 프로퍼티가 설정되면 서버 컴포넌트가 자동으로 활성화된다. 클라이언트 컴포넌트는 수동으로 시작해야 한다.

=== 원격 클라이언트 Application 실행하기
원격 클라이언트 application은 IDE 내에서 실행하도록 설계되어있다. 연결하려는 원격 프로젝트와 동일한 클래스패스를 사용하여 org.springframework.boot.devtools.RemoteSpringApplication을 실행해야 한다. RetmoteSpringApplication은 연결된 원격 프로젝트와 동일한 클래스패스를 가진다. application의 필수 인자(argument)는 연결되는 원격 URL이다.

예를 들어 Eclipse 또는 STS를 사용하고 Cloud Foundry에 배포할 프로젝트의 이름이 my-app인 다음을 수행한다:

* Run 메뉴에 Run Configurations...를 선택한다.
* 새로운 Java Application "launch configuration"을 생성한다.
* my-app 프로젝트를 찾는다.
* org.springframework.boot.devtools.RemoteSpringApplication 를 메인 클래스로 사용한다.
* https://myapp.cfapps.io를 프로그램 인자(arguments)에 추가한다. (또는 원격 URL을 추가한다.)

원격 클라이언트 실행 결과는 다음과 같다.
[source]
----
 .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 2.0.0.BUILD-SNAPSHOT

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)
----

[NOTE]
====
원격 클라이언트가 실제 application과 동일한 클래스패스를 사용하므로 application 프로퍼티를 직접 읽을 수 있다. spring.devtools.remote.secret 프로퍼티를 읽고 인증정보를 서버에 전달하는 방법이다.
====

[TIP]
====
트래픽이 암호화되고 암호를 가로챌 수 없도록 https://를 연결 프로토콜로 사용하는 것이 좋다.
====

[TIP]
====
프록시를 사용하여 원격 application에 엑세스해야 하는 경우 spring.devtools.remote.proxy.host 및 spring.devtools.remote.proxy.port 프로퍼티를 설정한다.
====

=== 원격 업데이트
원격 클라이언트는 application 클래스패스의 변경을 로컬 재시작과 같은 방법으로 모니터링한다. 업데이트된 리소스가 원격 application에 푸시되고 (필요한 경우) 재시작이 트리거된다. 이것은 로컬이 없는 클라우드 서비스를 사용하는 기능을 반복하는 경우 유용하다. 일반적으로 원격 업데이트 및 재시작은 전체 리빌드(rebuild) 및 배포 단계보다 훨씬 빠르다.

[NOTE]
====
파일은 원격 클라이언트가 실행 중일 때만 모니터링된다. 원격 클라이언트를 시작하기 전에 파일을 변경하면 원격 서버에 푸시되지 않는다.
====

== 21. 프로덕션을 위한 Application 패키징
실행가능한 jar는 프로덕션 배포를 위해 사용할 수 있다. 실행가능한 jar는 독립적이기 때문에 클라우드 기반 배포에 이상적이다.

health, auditing, metric REST 또는 JMX endpoints 같은 추가 "프로덕션 준비"기능을 사용하려면 spring-boot-actuator 추가하는 것을 고려하시오. 자세한 내용은 Part V "Spring Boot Actuator: 프로덕션 준비 기능"을 참조하시오.

== 22. 다음에 읽을 내용
이제 Spring Boot를 사용하는 방법과 모범 사례를 이해해야 한다. 이제 특정 Spring Boot 기능에 대해 자세히 배우거나, 건너뛰고 Spring Boot의 "프로덕션 준비"에 관해 읽을 수 있다.